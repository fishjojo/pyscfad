/*
 * Copyright (C) 2014-  Qiming Sun <osirpt.sun@gmail.com>
 * Description: code generated by  gen-code.cl
 */
#include <stdlib.h>
#include "gto/grid_ao_drv.h"
/*  #C(0 1) G |GTO> */
static void shell_eval_GTOval_ig(double *cgto, double *ri, double *exps,
double *coord, double *alpha, double *coeff, double *env,
int l, int np, int nc, size_t nao, size_t ngrids, size_t bgrids)
{
const size_t degen = (l+1)*(l+2)/2;
const size_t bgrids0 = (bgrids >= SIMDD) ? (bgrids+1-SIMDD) : 0;
int lx, ly, lz;
size_t i, j, j1, k, l1, n;
double e;
double *pgto;
double *gridx = coord;
double *gridy = coord+BLKSIZE;
double *gridz = coord+BLKSIZE*2;
double fx0[SIMDD*(ANG_MAX+2)*2];
double fy0[SIMDD*(ANG_MAX+2)*2];
double fz0[SIMDD*(ANG_MAX+2)*2];
double *fx1 = fx0 + SIMDD*(ANG_MAX+2);
double *fy1 = fy0 + SIMDD*(ANG_MAX+2);
double *fz1 = fz0 + SIMDD*(ANG_MAX+2);
double buf[SIMDD*nc*3];
double s[SIMDD*3];
double *gto0 = cgto;
double *gto1 = cgto + nao*ngrids*1;
double *gto2 = cgto + nao*ngrids*2;
double c[3];
c[0] = 1 * (-ri[0]);
c[1] = 1 * (-ri[1]);
c[2] = 1 * (-ri[2]);

for (j = 0; j < 3; j++) {
        pgto = cgto + j*nao*ngrids;
        for (n = 0; n < degen*nc; n++) {
        for (i = 0; i < bgrids; i++) {
                pgto[n*ngrids+i] = 0;
        } }
}
for (i = 0; i < bgrids0; i+=SIMDD) {
        for (k = 0; k < np; k++) {
                if (_nonzero_in(exps+k*BLKSIZE+i, SIMDD)) {
for (n = 0; n < SIMDD; n++) {
        fx0[n] = 1;
        fy0[n] = 1;
        fz0[n] = 1;
}
for (lx = 1; lx <= l+1; lx++) {
for (n = 0; n < SIMDD; n++) {
        fx0[lx*SIMDD+n] = fx0[(lx-1)*SIMDD+n] * gridx[i+n];
        fy0[lx*SIMDD+n] = fy0[(lx-1)*SIMDD+n] * gridy[i+n];
        fz0[lx*SIMDD+n] = fz0[(lx-1)*SIMDD+n] * gridz[i+n];
} }
GTO_R0I(1, 0, l+0);
for (lx = l, l1 = 0; lx >= 0; lx--) {
        for (ly = l - lx; ly >= 0; ly--, l1++) {
                lz = l - lx - ly;
                for (n = 0; n < SIMDD; n++) {
                       e = exps[k*BLKSIZE+i+n];
s[0*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[1*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[2*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz1[lz*SIMDD+n];
                }
                for (n = 0; n < SIMDD; n++) {
buf[0*SIMDD+n] = + (-1*c[1]*s[2*SIMDD+n]) + c[2]*s[1*SIMDD+n];
buf[1*SIMDD+n] = + (-1*c[2]*s[0*SIMDD+n]) + c[0]*s[2*SIMDD+n];
buf[2*SIMDD+n] = + (-1*c[0]*s[1*SIMDD+n]) + c[1]*s[0*SIMDD+n];
                }
                for (j = 0, j1 = l1; j < nc; j++, j1+=degen) {
#pragma GCC ivdep
                for (n = 0; n < SIMDD; n++) {
gto0[j1*ngrids+i+n] += buf[0*SIMDD+n] * coeff[j*np+k];
gto1[j1*ngrids+i+n] += buf[1*SIMDD+n] * coeff[j*np+k];
gto2[j1*ngrids+i+n] += buf[2*SIMDD+n] * coeff[j*np+k];
} } } } } } }

if (i < bgrids) {
        for (k = 0; k < np; k++) {
                if (_nonzero_in(exps+k*BLKSIZE+i, bgrids-i)) {
for (n = 0; n < SIMDD; n++) {
        fx0[n] = 1;
        fy0[n] = 1;
        fz0[n] = 1;
}
for (lx = 1; lx <= l+1; lx++) {
for (n = 0; n < SIMDD; n++) {
        fx0[lx*SIMDD+n] = fx0[(lx-1)*SIMDD+n] * gridx[i+n];
        fy0[lx*SIMDD+n] = fy0[(lx-1)*SIMDD+n] * gridy[i+n];
        fz0[lx*SIMDD+n] = fz0[(lx-1)*SIMDD+n] * gridz[i+n];
} }
GTO_R0I(1, 0, l+0);
for (lx = l, l1 = 0; lx >= 0; lx--) {
        for (ly = l - lx; ly >= 0; ly--, l1++) {
                lz = l - lx - ly;
                for (n = 0; n < SIMDD; n++) {
                       e = exps[k*BLKSIZE+i+n];
s[0*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[1*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[2*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz1[lz*SIMDD+n];
                }
                for (n = 0; n < SIMDD; n++) {
buf[0*SIMDD+n] = + (-1*c[1]*s[2*SIMDD+n]) + c[2]*s[1*SIMDD+n];
buf[1*SIMDD+n] = + (-1*c[2]*s[0*SIMDD+n]) + c[0]*s[2*SIMDD+n];
buf[2*SIMDD+n] = + (-1*c[0]*s[1*SIMDD+n]) + c[1]*s[0*SIMDD+n];
                }
                for (j = 0, j1 = l1; j < nc; j++, j1+=degen) {
                for (n = 0; n < bgrids-i; n++) {
gto0[j1*ngrids+i+n] += buf[0*SIMDD+n] * coeff[j*np+k];
gto1[j1*ngrids+i+n] += buf[1*SIMDD+n] * coeff[j*np+k];
gto2[j1*ngrids+i+n] += buf[2*SIMDD+n] * coeff[j*np+k];
} } } } } } }
}
void GTOval_ig_cart(int ngrids, int *shls_slice, int *ao_loc,
double *ao, double *coord, uint8_t *non0table,
int *atm, int natm, int *bas, int nbas, double *env)
{
int param[] = {1, 3};
GTOeval_cart_drv(shell_eval_GTOval_ig, GTOprim_exp, 0.5,
ngrids, param, shls_slice, ao_loc, ao, coord, non0table,
atm, natm, bas, nbas, env);
}
void GTOval_ig_sph(int ngrids, int *shls_slice, int *ao_loc,
double *ao, double *coord, uint8_t *non0table,
int *atm, int natm, int *bas, int nbas, double *env)
{
int param[] = {1, 3};
GTOeval_sph_drv(shell_eval_GTOval_ig, GTOprim_exp, 0.5,
ngrids, param, shls_slice, ao_loc, ao, coord, non0table,
atm, natm, bas, nbas, env);
}
void GTOval_ig_spinor(int ngrids, int *shls_slice, int *ao_loc,
double complex *ao, double *coord, uint8_t *non0table,
int *atm, int natm, int *bas, int nbas, double *env)
{
int param[] = {1, 3};
GTOeval_spinor_drv(shell_eval_GTOval_ig, GTOprim_exp, CINTc2s_iket_spinor_sf1, 0.5,
ngrids, param, shls_slice, ao_loc, ao, coord, non0table, atm, natm, bas, nbas, env);
}
/*  #C(0 1) NABLA G |GTO> */
static void shell_eval_GTOval_ipig(double *cgto, double *ri, double *exps,
double *coord, double *alpha, double *coeff, double *env,
int l, int np, int nc, size_t nao, size_t ngrids, size_t bgrids)
{
const size_t degen = (l+1)*(l+2)/2;
const size_t bgrids0 = (bgrids >= SIMDD) ? (bgrids+1-SIMDD) : 0;
int lx, ly, lz;
size_t i, j, j1, k, l1, n;
double e;
double *pgto;
double *gridx = coord;
double *gridy = coord+BLKSIZE;
double *gridz = coord+BLKSIZE*2;
double fx0[SIMDD*(ANG_MAX+3)*4];
double fy0[SIMDD*(ANG_MAX+3)*4];
double fz0[SIMDD*(ANG_MAX+3)*4];
double *fx1 = fx0 + SIMDD*(ANG_MAX+3);
double *fy1 = fy0 + SIMDD*(ANG_MAX+3);
double *fz1 = fz0 + SIMDD*(ANG_MAX+3);
double *fx2 = fx1 + SIMDD*(ANG_MAX+3);
double *fy2 = fy1 + SIMDD*(ANG_MAX+3);
double *fz2 = fz1 + SIMDD*(ANG_MAX+3);
double *fx3 = fx2 + SIMDD*(ANG_MAX+3);
double *fy3 = fy2 + SIMDD*(ANG_MAX+3);
double *fz3 = fz2 + SIMDD*(ANG_MAX+3);
double buf[SIMDD*nc*9];
double s[SIMDD*9];
double *gto0 = cgto;
double *gto1 = cgto + nao*ngrids*1;
double *gto2 = cgto + nao*ngrids*2;
double *gto3 = cgto + nao*ngrids*3;
double *gto4 = cgto + nao*ngrids*4;
double *gto5 = cgto + nao*ngrids*5;
double *gto6 = cgto + nao*ngrids*6;
double *gto7 = cgto + nao*ngrids*7;
double *gto8 = cgto + nao*ngrids*8;
double c[3];
c[0] = 1 * (-ri[0]);
c[1] = 1 * (-ri[1]);
c[2] = 1 * (-ri[2]);

for (j = 0; j < 9; j++) {
        pgto = cgto + j*nao*ngrids;
        for (n = 0; n < degen*nc; n++) {
        for (i = 0; i < bgrids; i++) {
                pgto[n*ngrids+i] = 0;
        } }
}
for (i = 0; i < bgrids0; i+=SIMDD) {
        for (k = 0; k < np; k++) {
                if (_nonzero_in(exps+k*BLKSIZE+i, SIMDD)) {
for (n = 0; n < SIMDD; n++) {
        fx0[n] = 1;
        fy0[n] = 1;
        fz0[n] = 1;
}
for (lx = 1; lx <= l+2; lx++) {
for (n = 0; n < SIMDD; n++) {
        fx0[lx*SIMDD+n] = fx0[(lx-1)*SIMDD+n] * gridx[i+n];
        fy0[lx*SIMDD+n] = fy0[(lx-1)*SIMDD+n] * gridy[i+n];
        fz0[lx*SIMDD+n] = fz0[(lx-1)*SIMDD+n] * gridz[i+n];
} }
GTO_R0I(1, 0, l+0);
GTO_D_I(2, 0, l+1);
GTO_R0I(3, 2, l+0);
for (lx = l, l1 = 0; lx >= 0; lx--) {
        for (ly = l - lx; ly >= 0; ly--, l1++) {
                lz = l - lx - ly;
                for (n = 0; n < SIMDD; n++) {
                       e = exps[k*BLKSIZE+i+n];
s[0*SIMDD+n] = e * fx3[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[1*SIMDD+n] = e * fx2[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[2*SIMDD+n] = e * fx2[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz1[lz*SIMDD+n];
s[3*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy2[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[4*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy3[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[5*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy2[ly*SIMDD+n] * fz1[lz*SIMDD+n];
s[6*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz2[lz*SIMDD+n];
s[7*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz2[lz*SIMDD+n];
s[8*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz3[lz*SIMDD+n];
                }
                for (n = 0; n < SIMDD; n++) {
buf[0*SIMDD+n] = + (-1*c[1]*s[2*SIMDD+n]) + c[2]*s[1*SIMDD+n];
buf[1*SIMDD+n] = + (-1*c[2]*s[0*SIMDD+n]) + c[0]*s[2*SIMDD+n];
buf[2*SIMDD+n] = + (-1*c[0]*s[1*SIMDD+n]) + c[1]*s[0*SIMDD+n];
buf[3*SIMDD+n] = + (-1*c[1]*s[5*SIMDD+n]) + c[2]*s[4*SIMDD+n];
buf[4*SIMDD+n] = + (-1*c[2]*s[3*SIMDD+n]) + c[0]*s[5*SIMDD+n];
buf[5*SIMDD+n] = + (-1*c[0]*s[4*SIMDD+n]) + c[1]*s[3*SIMDD+n];
buf[6*SIMDD+n] = + (-1*c[1]*s[8*SIMDD+n]) + c[2]*s[7*SIMDD+n];
buf[7*SIMDD+n] = + (-1*c[2]*s[6*SIMDD+n]) + c[0]*s[8*SIMDD+n];
buf[8*SIMDD+n] = + (-1*c[0]*s[7*SIMDD+n]) + c[1]*s[6*SIMDD+n];
                }
                for (j = 0, j1 = l1; j < nc; j++, j1+=degen) {
#pragma GCC ivdep
                for (n = 0; n < SIMDD; n++) {
gto0[j1*ngrids+i+n] += buf[0*SIMDD+n] * coeff[j*np+k];
gto1[j1*ngrids+i+n] += buf[1*SIMDD+n] * coeff[j*np+k];
gto2[j1*ngrids+i+n] += buf[2*SIMDD+n] * coeff[j*np+k];
gto3[j1*ngrids+i+n] += buf[3*SIMDD+n] * coeff[j*np+k];
gto4[j1*ngrids+i+n] += buf[4*SIMDD+n] * coeff[j*np+k];
gto5[j1*ngrids+i+n] += buf[5*SIMDD+n] * coeff[j*np+k];
gto6[j1*ngrids+i+n] += buf[6*SIMDD+n] * coeff[j*np+k];
gto7[j1*ngrids+i+n] += buf[7*SIMDD+n] * coeff[j*np+k];
gto8[j1*ngrids+i+n] += buf[8*SIMDD+n] * coeff[j*np+k];
} } } } } } }

if (i < bgrids) {
        for (k = 0; k < np; k++) {
                if (_nonzero_in(exps+k*BLKSIZE+i, bgrids-i)) {
for (n = 0; n < SIMDD; n++) {
        fx0[n] = 1;
        fy0[n] = 1;
        fz0[n] = 1;
}
for (lx = 1; lx <= l+2; lx++) {
for (n = 0; n < SIMDD; n++) {
        fx0[lx*SIMDD+n] = fx0[(lx-1)*SIMDD+n] * gridx[i+n];
        fy0[lx*SIMDD+n] = fy0[(lx-1)*SIMDD+n] * gridy[i+n];
        fz0[lx*SIMDD+n] = fz0[(lx-1)*SIMDD+n] * gridz[i+n];
} }
GTO_R0I(1, 0, l+0);
GTO_D_I(2, 0, l+1);
GTO_R0I(3, 2, l+0);
for (lx = l, l1 = 0; lx >= 0; lx--) {
        for (ly = l - lx; ly >= 0; ly--, l1++) {
                lz = l - lx - ly;
                for (n = 0; n < SIMDD; n++) {
                       e = exps[k*BLKSIZE+i+n];
s[0*SIMDD+n] = e * fx3[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[1*SIMDD+n] = e * fx2[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[2*SIMDD+n] = e * fx2[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz1[lz*SIMDD+n];
s[3*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy2[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[4*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy3[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[5*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy2[ly*SIMDD+n] * fz1[lz*SIMDD+n];
s[6*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz2[lz*SIMDD+n];
s[7*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz2[lz*SIMDD+n];
s[8*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz3[lz*SIMDD+n];
                }
                for (n = 0; n < SIMDD; n++) {
buf[0*SIMDD+n] = + (-1*c[1]*s[2*SIMDD+n]) + c[2]*s[1*SIMDD+n];
buf[1*SIMDD+n] = + (-1*c[2]*s[0*SIMDD+n]) + c[0]*s[2*SIMDD+n];
buf[2*SIMDD+n] = + (-1*c[0]*s[1*SIMDD+n]) + c[1]*s[0*SIMDD+n];
buf[3*SIMDD+n] = + (-1*c[1]*s[5*SIMDD+n]) + c[2]*s[4*SIMDD+n];
buf[4*SIMDD+n] = + (-1*c[2]*s[3*SIMDD+n]) + c[0]*s[5*SIMDD+n];
buf[5*SIMDD+n] = + (-1*c[0]*s[4*SIMDD+n]) + c[1]*s[3*SIMDD+n];
buf[6*SIMDD+n] = + (-1*c[1]*s[8*SIMDD+n]) + c[2]*s[7*SIMDD+n];
buf[7*SIMDD+n] = + (-1*c[2]*s[6*SIMDD+n]) + c[0]*s[8*SIMDD+n];
buf[8*SIMDD+n] = + (-1*c[0]*s[7*SIMDD+n]) + c[1]*s[6*SIMDD+n];
                }
                for (j = 0, j1 = l1; j < nc; j++, j1+=degen) {
                for (n = 0; n < bgrids-i; n++) {
gto0[j1*ngrids+i+n] += buf[0*SIMDD+n] * coeff[j*np+k];
gto1[j1*ngrids+i+n] += buf[1*SIMDD+n] * coeff[j*np+k];
gto2[j1*ngrids+i+n] += buf[2*SIMDD+n] * coeff[j*np+k];
gto3[j1*ngrids+i+n] += buf[3*SIMDD+n] * coeff[j*np+k];
gto4[j1*ngrids+i+n] += buf[4*SIMDD+n] * coeff[j*np+k];
gto5[j1*ngrids+i+n] += buf[5*SIMDD+n] * coeff[j*np+k];
gto6[j1*ngrids+i+n] += buf[6*SIMDD+n] * coeff[j*np+k];
gto7[j1*ngrids+i+n] += buf[7*SIMDD+n] * coeff[j*np+k];
gto8[j1*ngrids+i+n] += buf[8*SIMDD+n] * coeff[j*np+k];
} } } } } } }
}
void GTOval_ipig_cart(int ngrids, int *shls_slice, int *ao_loc,
double *ao, double *coord, uint8_t *non0table,
int *atm, int natm, int *bas, int nbas, double *env)
{
int param[] = {1, 9};
GTOeval_cart_drv(shell_eval_GTOval_ipig, GTOprim_exp, 0.5,
ngrids, param, shls_slice, ao_loc, ao, coord, non0table,
atm, natm, bas, nbas, env);
}
void GTOval_ipig_sph(int ngrids, int *shls_slice, int *ao_loc,
double *ao, double *coord, uint8_t *non0table,
int *atm, int natm, int *bas, int nbas, double *env)
{
int param[] = {1, 9};
GTOeval_sph_drv(shell_eval_GTOval_ipig, GTOprim_exp, 0.5,
ngrids, param, shls_slice, ao_loc, ao, coord, non0table,
atm, natm, bas, nbas, env);
}
void GTOval_ipig_spinor(int ngrids, int *shls_slice, int *ao_loc,
double complex *ao, double *coord, uint8_t *non0table,
int *atm, int natm, int *bas, int nbas, double *env)
{
int param[] = {1, 9};
GTOeval_spinor_drv(shell_eval_GTOval_ipig, GTOprim_exp, CINTc2s_iket_spinor_sf1, 0.5,
ngrids, param, shls_slice, ao_loc, ao, coord, non0table, atm, natm, bas, nbas, env);
}
/*  SIGMA DOT P |GTO> */
static void shell_eval_GTOval_sp(double *cgto, double *ri, double *exps,
double *coord, double *alpha, double *coeff, double *env,
int l, int np, int nc, size_t nao, size_t ngrids, size_t bgrids)
{
const size_t degen = (l+1)*(l+2)/2;
const size_t bgrids0 = (bgrids >= SIMDD) ? (bgrids+1-SIMDD) : 0;
int lx, ly, lz;
size_t i, j, j1, k, l1, n;
double e;
double *pgto;
double *gridx = coord;
double *gridy = coord+BLKSIZE;
double *gridz = coord+BLKSIZE*2;
double fx0[SIMDD*(ANG_MAX+2)*2];
double fy0[SIMDD*(ANG_MAX+2)*2];
double fz0[SIMDD*(ANG_MAX+2)*2];
double *fx1 = fx0 + SIMDD*(ANG_MAX+2);
double *fy1 = fy0 + SIMDD*(ANG_MAX+2);
double *fz1 = fz0 + SIMDD*(ANG_MAX+2);
double buf[SIMDD*nc*4];
double s[SIMDD*3];
double *gto0 = cgto;
double *gto1 = cgto + nao*ngrids*1;
double *gto2 = cgto + nao*ngrids*2;
double *gto3 = cgto + nao*ngrids*3;

for (j = 0; j < 4; j++) {
        pgto = cgto + j*nao*ngrids;
        for (n = 0; n < degen*nc; n++) {
        for (i = 0; i < bgrids; i++) {
                pgto[n*ngrids+i] = 0;
        } }
}
for (i = 0; i < bgrids0; i+=SIMDD) {
        for (k = 0; k < np; k++) {
                if (_nonzero_in(exps+k*BLKSIZE+i, SIMDD)) {
for (n = 0; n < SIMDD; n++) {
        fx0[n] = 1;
        fy0[n] = 1;
        fz0[n] = 1;
}
for (lx = 1; lx <= l+1; lx++) {
for (n = 0; n < SIMDD; n++) {
        fx0[lx*SIMDD+n] = fx0[(lx-1)*SIMDD+n] * gridx[i+n];
        fy0[lx*SIMDD+n] = fy0[(lx-1)*SIMDD+n] * gridy[i+n];
        fz0[lx*SIMDD+n] = fz0[(lx-1)*SIMDD+n] * gridz[i+n];
} }
GTO_D_I(1, 0, l+0);
for (lx = l, l1 = 0; lx >= 0; lx--) {
        for (ly = l - lx; ly >= 0; ly--, l1++) {
                lz = l - lx - ly;
                for (n = 0; n < SIMDD; n++) {
                       e = exps[k*BLKSIZE+i+n];
s[0*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[1*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[2*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz1[lz*SIMDD+n];
                }
                for (n = 0; n < SIMDD; n++) {
buf[0*SIMDD+n] = + (-1*s[0*SIMDD+n]);
buf[1*SIMDD+n] = + (-1*s[1*SIMDD+n]);
buf[2*SIMDD+n] = + (-1*s[2*SIMDD+n]);
buf[3*SIMDD+n] = 0;
                }
                for (j = 0, j1 = l1; j < nc; j++, j1+=degen) {
#pragma GCC ivdep
                for (n = 0; n < SIMDD; n++) {
gto0[j1*ngrids+i+n] += buf[0*SIMDD+n] * coeff[j*np+k];
gto1[j1*ngrids+i+n] += buf[1*SIMDD+n] * coeff[j*np+k];
gto2[j1*ngrids+i+n] += buf[2*SIMDD+n] * coeff[j*np+k];
gto3[j1*ngrids+i+n] += buf[3*SIMDD+n] * coeff[j*np+k];
} } } } } } }

if (i < bgrids) {
        for (k = 0; k < np; k++) {
                if (_nonzero_in(exps+k*BLKSIZE+i, bgrids-i)) {
for (n = 0; n < SIMDD; n++) {
        fx0[n] = 1;
        fy0[n] = 1;
        fz0[n] = 1;
}
for (lx = 1; lx <= l+1; lx++) {
for (n = 0; n < SIMDD; n++) {
        fx0[lx*SIMDD+n] = fx0[(lx-1)*SIMDD+n] * gridx[i+n];
        fy0[lx*SIMDD+n] = fy0[(lx-1)*SIMDD+n] * gridy[i+n];
        fz0[lx*SIMDD+n] = fz0[(lx-1)*SIMDD+n] * gridz[i+n];
} }
GTO_D_I(1, 0, l+0);
for (lx = l, l1 = 0; lx >= 0; lx--) {
        for (ly = l - lx; ly >= 0; ly--, l1++) {
                lz = l - lx - ly;
                for (n = 0; n < SIMDD; n++) {
                       e = exps[k*BLKSIZE+i+n];
s[0*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[1*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[2*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz1[lz*SIMDD+n];
                }
                for (n = 0; n < SIMDD; n++) {
buf[0*SIMDD+n] = + (-1*s[0*SIMDD+n]);
buf[1*SIMDD+n] = + (-1*s[1*SIMDD+n]);
buf[2*SIMDD+n] = + (-1*s[2*SIMDD+n]);
buf[3*SIMDD+n] = 0;
                }
                for (j = 0, j1 = l1; j < nc; j++, j1+=degen) {
                for (n = 0; n < bgrids-i; n++) {
gto0[j1*ngrids+i+n] += buf[0*SIMDD+n] * coeff[j*np+k];
gto1[j1*ngrids+i+n] += buf[1*SIMDD+n] * coeff[j*np+k];
gto2[j1*ngrids+i+n] += buf[2*SIMDD+n] * coeff[j*np+k];
gto3[j1*ngrids+i+n] += buf[3*SIMDD+n] * coeff[j*np+k];
} } } } } } }
}
void GTOval_sp_cart(int ngrids, int *shls_slice, int *ao_loc,
double *ao, double *coord, uint8_t *non0table,
int *atm, int natm, int *bas, int nbas, double *env)
{
int param[] = {4, 1};
GTOeval_cart_drv(shell_eval_GTOval_sp, GTOprim_exp, 1,
ngrids, param, shls_slice, ao_loc, ao, coord, non0table,
atm, natm, bas, nbas, env);
}
void GTOval_sp_sph(int ngrids, int *shls_slice, int *ao_loc,
double *ao, double *coord, uint8_t *non0table,
int *atm, int natm, int *bas, int nbas, double *env)
{
int param[] = {4, 1};
GTOeval_sph_drv(shell_eval_GTOval_sp, GTOprim_exp, 1,
ngrids, param, shls_slice, ao_loc, ao, coord, non0table,
atm, natm, bas, nbas, env);
}
void GTOval_sp_spinor(int ngrids, int *shls_slice, int *ao_loc,
double complex *ao, double *coord, uint8_t *non0table,
int *atm, int natm, int *bas, int nbas, double *env)
{
int param[] = {4, 1};
GTOeval_spinor_drv(shell_eval_GTOval_sp, GTOprim_exp, CINTc2s_ket_spinor_si1, 1,
ngrids, param, shls_slice, ao_loc, ao, coord, non0table, atm, natm, bas, nbas, env);
}
/*  NABLA SIGMA DOT P |GTO> */
static void shell_eval_GTOval_ipsp(double *cgto, double *ri, double *exps,
double *coord, double *alpha, double *coeff, double *env,
int l, int np, int nc, size_t nao, size_t ngrids, size_t bgrids)
{
const size_t degen = (l+1)*(l+2)/2;
const size_t bgrids0 = (bgrids >= SIMDD) ? (bgrids+1-SIMDD) : 0;
int lx, ly, lz;
size_t i, j, j1, k, l1, n;
double e;
double *pgto;
double *gridx = coord;
double *gridy = coord+BLKSIZE;
double *gridz = coord+BLKSIZE*2;
double fx0[SIMDD*(ANG_MAX+3)*4];
double fy0[SIMDD*(ANG_MAX+3)*4];
double fz0[SIMDD*(ANG_MAX+3)*4];
double *fx1 = fx0 + SIMDD*(ANG_MAX+3);
double *fy1 = fy0 + SIMDD*(ANG_MAX+3);
double *fz1 = fz0 + SIMDD*(ANG_MAX+3);
double *fx2 = fx1 + SIMDD*(ANG_MAX+3);
double *fy2 = fy1 + SIMDD*(ANG_MAX+3);
double *fz2 = fz1 + SIMDD*(ANG_MAX+3);
double *fx3 = fx2 + SIMDD*(ANG_MAX+3);
double *fy3 = fy2 + SIMDD*(ANG_MAX+3);
double *fz3 = fz2 + SIMDD*(ANG_MAX+3);
double buf[SIMDD*nc*12];
double s[SIMDD*9];
double *gto0 = cgto;
double *gto1 = cgto + nao*ngrids*1;
double *gto2 = cgto + nao*ngrids*2;
double *gto3 = cgto + nao*ngrids*3;
double *gto4 = cgto + nao*ngrids*4;
double *gto5 = cgto + nao*ngrids*5;
double *gto6 = cgto + nao*ngrids*6;
double *gto7 = cgto + nao*ngrids*7;
double *gto8 = cgto + nao*ngrids*8;
double *gto9 = cgto + nao*ngrids*9;
double *gto10 = cgto + nao*ngrids*10;
double *gto11 = cgto + nao*ngrids*11;

for (j = 0; j < 12; j++) {
        pgto = cgto + j*nao*ngrids;
        for (n = 0; n < degen*nc; n++) {
        for (i = 0; i < bgrids; i++) {
                pgto[n*ngrids+i] = 0;
        } }
}
for (i = 0; i < bgrids0; i+=SIMDD) {
        for (k = 0; k < np; k++) {
                if (_nonzero_in(exps+k*BLKSIZE+i, SIMDD)) {
for (n = 0; n < SIMDD; n++) {
        fx0[n] = 1;
        fy0[n] = 1;
        fz0[n] = 1;
}
for (lx = 1; lx <= l+2; lx++) {
for (n = 0; n < SIMDD; n++) {
        fx0[lx*SIMDD+n] = fx0[(lx-1)*SIMDD+n] * gridx[i+n];
        fy0[lx*SIMDD+n] = fy0[(lx-1)*SIMDD+n] * gridy[i+n];
        fz0[lx*SIMDD+n] = fz0[(lx-1)*SIMDD+n] * gridz[i+n];
} }
GTO_D_I(1, 0, l+0);
GTO_D_I(2, 0, l+1);
GTO_D_I(3, 2, l+0);
for (lx = l, l1 = 0; lx >= 0; lx--) {
        for (ly = l - lx; ly >= 0; ly--, l1++) {
                lz = l - lx - ly;
                for (n = 0; n < SIMDD; n++) {
                       e = exps[k*BLKSIZE+i+n];
s[0*SIMDD+n] = e * fx3[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[1*SIMDD+n] = e * fx2[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[2*SIMDD+n] = e * fx2[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz1[lz*SIMDD+n];
s[3*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy2[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[4*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy3[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[5*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy2[ly*SIMDD+n] * fz1[lz*SIMDD+n];
s[6*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz2[lz*SIMDD+n];
s[7*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz2[lz*SIMDD+n];
s[8*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz3[lz*SIMDD+n];
                }
                for (n = 0; n < SIMDD; n++) {
buf[0*SIMDD+n] = + (-1*s[0*SIMDD+n]);
buf[1*SIMDD+n] = + (-1*s[1*SIMDD+n]);
buf[2*SIMDD+n] = + (-1*s[2*SIMDD+n]);
buf[3*SIMDD+n] = 0;
buf[4*SIMDD+n] = + (-1*s[3*SIMDD+n]);
buf[5*SIMDD+n] = + (-1*s[4*SIMDD+n]);
buf[6*SIMDD+n] = + (-1*s[5*SIMDD+n]);
buf[7*SIMDD+n] = 0;
buf[8*SIMDD+n] = + (-1*s[6*SIMDD+n]);
buf[9*SIMDD+n] = + (-1*s[7*SIMDD+n]);
buf[10*SIMDD+n] = + (-1*s[8*SIMDD+n]);
buf[11*SIMDD+n] = 0;
                }
                for (j = 0, j1 = l1; j < nc; j++, j1+=degen) {
#pragma GCC ivdep
                for (n = 0; n < SIMDD; n++) {
gto0[j1*ngrids+i+n] += buf[0*SIMDD+n] * coeff[j*np+k];
gto1[j1*ngrids+i+n] += buf[1*SIMDD+n] * coeff[j*np+k];
gto2[j1*ngrids+i+n] += buf[2*SIMDD+n] * coeff[j*np+k];
gto3[j1*ngrids+i+n] += buf[3*SIMDD+n] * coeff[j*np+k];
gto4[j1*ngrids+i+n] += buf[4*SIMDD+n] * coeff[j*np+k];
gto5[j1*ngrids+i+n] += buf[5*SIMDD+n] * coeff[j*np+k];
gto6[j1*ngrids+i+n] += buf[6*SIMDD+n] * coeff[j*np+k];
gto7[j1*ngrids+i+n] += buf[7*SIMDD+n] * coeff[j*np+k];
gto8[j1*ngrids+i+n] += buf[8*SIMDD+n] * coeff[j*np+k];
gto9[j1*ngrids+i+n] += buf[9*SIMDD+n] * coeff[j*np+k];
gto10[j1*ngrids+i+n] += buf[10*SIMDD+n] * coeff[j*np+k];
gto11[j1*ngrids+i+n] += buf[11*SIMDD+n] * coeff[j*np+k];
} } } } } } }

if (i < bgrids) {
        for (k = 0; k < np; k++) {
                if (_nonzero_in(exps+k*BLKSIZE+i, bgrids-i)) {
for (n = 0; n < SIMDD; n++) {
        fx0[n] = 1;
        fy0[n] = 1;
        fz0[n] = 1;
}
for (lx = 1; lx <= l+2; lx++) {
for (n = 0; n < SIMDD; n++) {
        fx0[lx*SIMDD+n] = fx0[(lx-1)*SIMDD+n] * gridx[i+n];
        fy0[lx*SIMDD+n] = fy0[(lx-1)*SIMDD+n] * gridy[i+n];
        fz0[lx*SIMDD+n] = fz0[(lx-1)*SIMDD+n] * gridz[i+n];
} }
GTO_D_I(1, 0, l+0);
GTO_D_I(2, 0, l+1);
GTO_D_I(3, 2, l+0);
for (lx = l, l1 = 0; lx >= 0; lx--) {
        for (ly = l - lx; ly >= 0; ly--, l1++) {
                lz = l - lx - ly;
                for (n = 0; n < SIMDD; n++) {
                       e = exps[k*BLKSIZE+i+n];
s[0*SIMDD+n] = e * fx3[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[1*SIMDD+n] = e * fx2[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[2*SIMDD+n] = e * fx2[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz1[lz*SIMDD+n];
s[3*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy2[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[4*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy3[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[5*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy2[ly*SIMDD+n] * fz1[lz*SIMDD+n];
s[6*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz2[lz*SIMDD+n];
s[7*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz2[lz*SIMDD+n];
s[8*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz3[lz*SIMDD+n];
                }
                for (n = 0; n < SIMDD; n++) {
buf[0*SIMDD+n] = + (-1*s[0*SIMDD+n]);
buf[1*SIMDD+n] = + (-1*s[1*SIMDD+n]);
buf[2*SIMDD+n] = + (-1*s[2*SIMDD+n]);
buf[3*SIMDD+n] = 0;
buf[4*SIMDD+n] = + (-1*s[3*SIMDD+n]);
buf[5*SIMDD+n] = + (-1*s[4*SIMDD+n]);
buf[6*SIMDD+n] = + (-1*s[5*SIMDD+n]);
buf[7*SIMDD+n] = 0;
buf[8*SIMDD+n] = + (-1*s[6*SIMDD+n]);
buf[9*SIMDD+n] = + (-1*s[7*SIMDD+n]);
buf[10*SIMDD+n] = + (-1*s[8*SIMDD+n]);
buf[11*SIMDD+n] = 0;
                }
                for (j = 0, j1 = l1; j < nc; j++, j1+=degen) {
                for (n = 0; n < bgrids-i; n++) {
gto0[j1*ngrids+i+n] += buf[0*SIMDD+n] * coeff[j*np+k];
gto1[j1*ngrids+i+n] += buf[1*SIMDD+n] * coeff[j*np+k];
gto2[j1*ngrids+i+n] += buf[2*SIMDD+n] * coeff[j*np+k];
gto3[j1*ngrids+i+n] += buf[3*SIMDD+n] * coeff[j*np+k];
gto4[j1*ngrids+i+n] += buf[4*SIMDD+n] * coeff[j*np+k];
gto5[j1*ngrids+i+n] += buf[5*SIMDD+n] * coeff[j*np+k];
gto6[j1*ngrids+i+n] += buf[6*SIMDD+n] * coeff[j*np+k];
gto7[j1*ngrids+i+n] += buf[7*SIMDD+n] * coeff[j*np+k];
gto8[j1*ngrids+i+n] += buf[8*SIMDD+n] * coeff[j*np+k];
gto9[j1*ngrids+i+n] += buf[9*SIMDD+n] * coeff[j*np+k];
gto10[j1*ngrids+i+n] += buf[10*SIMDD+n] * coeff[j*np+k];
gto11[j1*ngrids+i+n] += buf[11*SIMDD+n] * coeff[j*np+k];
} } } } } } }
}
void GTOval_ipsp_cart(int ngrids, int *shls_slice, int *ao_loc,
double *ao, double *coord, uint8_t *non0table,
int *atm, int natm, int *bas, int nbas, double *env)
{
int param[] = {4, 3};
GTOeval_cart_drv(shell_eval_GTOval_ipsp, GTOprim_exp, 1,
ngrids, param, shls_slice, ao_loc, ao, coord, non0table,
atm, natm, bas, nbas, env);
}
void GTOval_ipsp_sph(int ngrids, int *shls_slice, int *ao_loc,
double *ao, double *coord, uint8_t *non0table,
int *atm, int natm, int *bas, int nbas, double *env)
{
int param[] = {4, 3};
GTOeval_sph_drv(shell_eval_GTOval_ipsp, GTOprim_exp, 1,
ngrids, param, shls_slice, ao_loc, ao, coord, non0table,
atm, natm, bas, nbas, env);
}
void GTOval_ipsp_spinor(int ngrids, int *shls_slice, int *ao_loc,
double complex *ao, double *coord, uint8_t *non0table,
int *atm, int natm, int *bas, int nbas, double *env)
{
int param[] = {4, 3};
GTOeval_spinor_drv(shell_eval_GTOval_ipsp, GTOprim_exp, CINTc2s_ket_spinor_si1, 1,
ngrids, param, shls_slice, ao_loc, ao, coord, non0table, atm, natm, bas, nbas, env);
}
/*  NABLA NABLA SIGMA DOT P |GTO> */
static void shell_eval_GTOval_ipipsp(double *cgto, double *ri, double *exps,
double *coord, double *alpha, double *coeff, double *env,
int l, int np, int nc, size_t nao, size_t ngrids, size_t bgrids)
{
const size_t degen = (l+1)*(l+2)/2;
const size_t bgrids0 = (bgrids >= SIMDD) ? (bgrids+1-SIMDD) : 0;
int lx, ly, lz;
size_t i, j, j1, k, l1, n;
double e;
double *pgto;
double *gridx = coord;
double *gridy = coord+BLKSIZE;
double *gridz = coord+BLKSIZE*2;
double fx0[SIMDD*(ANG_MAX+4)*8];
double fy0[SIMDD*(ANG_MAX+4)*8];
double fz0[SIMDD*(ANG_MAX+4)*8];
double *fx1 = fx0 + SIMDD*(ANG_MAX+4);
double *fy1 = fy0 + SIMDD*(ANG_MAX+4);
double *fz1 = fz0 + SIMDD*(ANG_MAX+4);
double *fx2 = fx1 + SIMDD*(ANG_MAX+4);
double *fy2 = fy1 + SIMDD*(ANG_MAX+4);
double *fz2 = fz1 + SIMDD*(ANG_MAX+4);
double *fx3 = fx2 + SIMDD*(ANG_MAX+4);
double *fy3 = fy2 + SIMDD*(ANG_MAX+4);
double *fz3 = fz2 + SIMDD*(ANG_MAX+4);
double *fx4 = fx3 + SIMDD*(ANG_MAX+4);
double *fy4 = fy3 + SIMDD*(ANG_MAX+4);
double *fz4 = fz3 + SIMDD*(ANG_MAX+4);
double *fx5 = fx4 + SIMDD*(ANG_MAX+4);
double *fy5 = fy4 + SIMDD*(ANG_MAX+4);
double *fz5 = fz4 + SIMDD*(ANG_MAX+4);
double *fx6 = fx5 + SIMDD*(ANG_MAX+4);
double *fy6 = fy5 + SIMDD*(ANG_MAX+4);
double *fz6 = fz5 + SIMDD*(ANG_MAX+4);
double *fx7 = fx6 + SIMDD*(ANG_MAX+4);
double *fy7 = fy6 + SIMDD*(ANG_MAX+4);
double *fz7 = fz6 + SIMDD*(ANG_MAX+4);
double buf[SIMDD*nc*36];
double s[SIMDD*27];
double *gto0 = cgto;
double *gto1 = cgto + nao*ngrids*1;
double *gto2 = cgto + nao*ngrids*2;
double *gto3 = cgto + nao*ngrids*3;
double *gto4 = cgto + nao*ngrids*4;
double *gto5 = cgto + nao*ngrids*5;
double *gto6 = cgto + nao*ngrids*6;
double *gto7 = cgto + nao*ngrids*7;
double *gto8 = cgto + nao*ngrids*8;
double *gto9 = cgto + nao*ngrids*9;
double *gto10 = cgto + nao*ngrids*10;
double *gto11 = cgto + nao*ngrids*11;
double *gto12 = cgto + nao*ngrids*12;
double *gto13 = cgto + nao*ngrids*13;
double *gto14 = cgto + nao*ngrids*14;
double *gto15 = cgto + nao*ngrids*15;
double *gto16 = cgto + nao*ngrids*16;
double *gto17 = cgto + nao*ngrids*17;
double *gto18 = cgto + nao*ngrids*18;
double *gto19 = cgto + nao*ngrids*19;
double *gto20 = cgto + nao*ngrids*20;
double *gto21 = cgto + nao*ngrids*21;
double *gto22 = cgto + nao*ngrids*22;
double *gto23 = cgto + nao*ngrids*23;
double *gto24 = cgto + nao*ngrids*24;
double *gto25 = cgto + nao*ngrids*25;
double *gto26 = cgto + nao*ngrids*26;
double *gto27 = cgto + nao*ngrids*27;
double *gto28 = cgto + nao*ngrids*28;
double *gto29 = cgto + nao*ngrids*29;
double *gto30 = cgto + nao*ngrids*30;
double *gto31 = cgto + nao*ngrids*31;
double *gto32 = cgto + nao*ngrids*32;
double *gto33 = cgto + nao*ngrids*33;
double *gto34 = cgto + nao*ngrids*34;
double *gto35 = cgto + nao*ngrids*35;

for (j = 0; j < 36; j++) {
        pgto = cgto + j*nao*ngrids;
        for (n = 0; n < degen*nc; n++) {
        for (i = 0; i < bgrids; i++) {
                pgto[n*ngrids+i] = 0;
        } }
}
for (i = 0; i < bgrids0; i+=SIMDD) {
        for (k = 0; k < np; k++) {
                if (_nonzero_in(exps+k*BLKSIZE+i, SIMDD)) {
for (n = 0; n < SIMDD; n++) {
        fx0[n] = 1;
        fy0[n] = 1;
        fz0[n] = 1;
}
for (lx = 1; lx <= l+3; lx++) {
for (n = 0; n < SIMDD; n++) {
        fx0[lx*SIMDD+n] = fx0[(lx-1)*SIMDD+n] * gridx[i+n];
        fy0[lx*SIMDD+n] = fy0[(lx-1)*SIMDD+n] * gridy[i+n];
        fz0[lx*SIMDD+n] = fz0[(lx-1)*SIMDD+n] * gridz[i+n];
} }
GTO_D_I(1, 0, l+0);
GTO_D_I(2, 0, l+1);
GTO_D_I(3, 2, l+0);
GTO_D_I(4, 0, l+2);
GTO_D_I(5, 4, l+0);
GTO_D_I(6, 4, l+1);
GTO_D_I(7, 6, l+0);
for (lx = l, l1 = 0; lx >= 0; lx--) {
        for (ly = l - lx; ly >= 0; ly--, l1++) {
                lz = l - lx - ly;
                for (n = 0; n < SIMDD; n++) {
                       e = exps[k*BLKSIZE+i+n];
s[0*SIMDD+n] = e * fx7[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[1*SIMDD+n] = e * fx6[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[2*SIMDD+n] = e * fx6[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz1[lz*SIMDD+n];
s[3*SIMDD+n] = e * fx5[lx*SIMDD+n] * fy2[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[4*SIMDD+n] = e * fx4[lx*SIMDD+n] * fy3[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[5*SIMDD+n] = e * fx4[lx*SIMDD+n] * fy2[ly*SIMDD+n] * fz1[lz*SIMDD+n];
s[6*SIMDD+n] = e * fx5[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz2[lz*SIMDD+n];
s[7*SIMDD+n] = e * fx4[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz2[lz*SIMDD+n];
s[8*SIMDD+n] = e * fx4[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz3[lz*SIMDD+n];
s[9*SIMDD+n] = e * fx3[lx*SIMDD+n] * fy4[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[10*SIMDD+n] = e * fx2[lx*SIMDD+n] * fy5[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[11*SIMDD+n] = e * fx2[lx*SIMDD+n] * fy4[ly*SIMDD+n] * fz1[lz*SIMDD+n];
s[12*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy6[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[13*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy7[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[14*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy6[ly*SIMDD+n] * fz1[lz*SIMDD+n];
s[15*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy4[ly*SIMDD+n] * fz2[lz*SIMDD+n];
s[16*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy5[ly*SIMDD+n] * fz2[lz*SIMDD+n];
s[17*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy4[ly*SIMDD+n] * fz3[lz*SIMDD+n];
s[18*SIMDD+n] = e * fx3[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz4[lz*SIMDD+n];
s[19*SIMDD+n] = e * fx2[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz4[lz*SIMDD+n];
s[20*SIMDD+n] = e * fx2[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz5[lz*SIMDD+n];
s[21*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy2[ly*SIMDD+n] * fz4[lz*SIMDD+n];
s[22*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy3[ly*SIMDD+n] * fz4[lz*SIMDD+n];
s[23*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy2[ly*SIMDD+n] * fz5[lz*SIMDD+n];
s[24*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz6[lz*SIMDD+n];
s[25*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz6[lz*SIMDD+n];
s[26*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz7[lz*SIMDD+n];
                }
                for (n = 0; n < SIMDD; n++) {
buf[0*SIMDD+n] = + (-1*s[0*SIMDD+n]);
buf[1*SIMDD+n] = + (-1*s[1*SIMDD+n]);
buf[2*SIMDD+n] = + (-1*s[2*SIMDD+n]);
buf[3*SIMDD+n] = 0;
buf[4*SIMDD+n] = + (-1*s[3*SIMDD+n]);
buf[5*SIMDD+n] = + (-1*s[4*SIMDD+n]);
buf[6*SIMDD+n] = + (-1*s[5*SIMDD+n]);
buf[7*SIMDD+n] = 0;
buf[8*SIMDD+n] = + (-1*s[6*SIMDD+n]);
buf[9*SIMDD+n] = + (-1*s[7*SIMDD+n]);
buf[10*SIMDD+n] = + (-1*s[8*SIMDD+n]);
buf[11*SIMDD+n] = 0;
buf[12*SIMDD+n] = + (-1*s[9*SIMDD+n]);
buf[13*SIMDD+n] = + (-1*s[10*SIMDD+n]);
buf[14*SIMDD+n] = + (-1*s[11*SIMDD+n]);
buf[15*SIMDD+n] = 0;
buf[16*SIMDD+n] = + (-1*s[12*SIMDD+n]);
buf[17*SIMDD+n] = + (-1*s[13*SIMDD+n]);
buf[18*SIMDD+n] = + (-1*s[14*SIMDD+n]);
buf[19*SIMDD+n] = 0;
buf[20*SIMDD+n] = + (-1*s[15*SIMDD+n]);
buf[21*SIMDD+n] = + (-1*s[16*SIMDD+n]);
buf[22*SIMDD+n] = + (-1*s[17*SIMDD+n]);
buf[23*SIMDD+n] = 0;
buf[24*SIMDD+n] = + (-1*s[18*SIMDD+n]);
buf[25*SIMDD+n] = + (-1*s[19*SIMDD+n]);
buf[26*SIMDD+n] = + (-1*s[20*SIMDD+n]);
buf[27*SIMDD+n] = 0;
buf[28*SIMDD+n] = + (-1*s[21*SIMDD+n]);
buf[29*SIMDD+n] = + (-1*s[22*SIMDD+n]);
buf[30*SIMDD+n] = + (-1*s[23*SIMDD+n]);
buf[31*SIMDD+n] = 0;
buf[32*SIMDD+n] = + (-1*s[24*SIMDD+n]);
buf[33*SIMDD+n] = + (-1*s[25*SIMDD+n]);
buf[34*SIMDD+n] = + (-1*s[26*SIMDD+n]);
buf[35*SIMDD+n] = 0;
                }
                for (j = 0, j1 = l1; j < nc; j++, j1+=degen) {
#pragma GCC ivdep
                for (n = 0; n < SIMDD; n++) {
gto0[j1*ngrids+i+n] += buf[0*SIMDD+n] * coeff[j*np+k];
gto1[j1*ngrids+i+n] += buf[1*SIMDD+n] * coeff[j*np+k];
gto2[j1*ngrids+i+n] += buf[2*SIMDD+n] * coeff[j*np+k];
gto3[j1*ngrids+i+n] += buf[3*SIMDD+n] * coeff[j*np+k];
gto4[j1*ngrids+i+n] += buf[4*SIMDD+n] * coeff[j*np+k];
gto5[j1*ngrids+i+n] += buf[5*SIMDD+n] * coeff[j*np+k];
gto6[j1*ngrids+i+n] += buf[6*SIMDD+n] * coeff[j*np+k];
gto7[j1*ngrids+i+n] += buf[7*SIMDD+n] * coeff[j*np+k];
gto8[j1*ngrids+i+n] += buf[8*SIMDD+n] * coeff[j*np+k];
gto9[j1*ngrids+i+n] += buf[9*SIMDD+n] * coeff[j*np+k];
gto10[j1*ngrids+i+n] += buf[10*SIMDD+n] * coeff[j*np+k];
gto11[j1*ngrids+i+n] += buf[11*SIMDD+n] * coeff[j*np+k];
gto12[j1*ngrids+i+n] += buf[12*SIMDD+n] * coeff[j*np+k];
gto13[j1*ngrids+i+n] += buf[13*SIMDD+n] * coeff[j*np+k];
gto14[j1*ngrids+i+n] += buf[14*SIMDD+n] * coeff[j*np+k];
gto15[j1*ngrids+i+n] += buf[15*SIMDD+n] * coeff[j*np+k];
gto16[j1*ngrids+i+n] += buf[16*SIMDD+n] * coeff[j*np+k];
gto17[j1*ngrids+i+n] += buf[17*SIMDD+n] * coeff[j*np+k];
gto18[j1*ngrids+i+n] += buf[18*SIMDD+n] * coeff[j*np+k];
gto19[j1*ngrids+i+n] += buf[19*SIMDD+n] * coeff[j*np+k];
gto20[j1*ngrids+i+n] += buf[20*SIMDD+n] * coeff[j*np+k];
gto21[j1*ngrids+i+n] += buf[21*SIMDD+n] * coeff[j*np+k];
gto22[j1*ngrids+i+n] += buf[22*SIMDD+n] * coeff[j*np+k];
gto23[j1*ngrids+i+n] += buf[23*SIMDD+n] * coeff[j*np+k];
gto24[j1*ngrids+i+n] += buf[24*SIMDD+n] * coeff[j*np+k];
gto25[j1*ngrids+i+n] += buf[25*SIMDD+n] * coeff[j*np+k];
gto26[j1*ngrids+i+n] += buf[26*SIMDD+n] * coeff[j*np+k];
gto27[j1*ngrids+i+n] += buf[27*SIMDD+n] * coeff[j*np+k];
gto28[j1*ngrids+i+n] += buf[28*SIMDD+n] * coeff[j*np+k];
gto29[j1*ngrids+i+n] += buf[29*SIMDD+n] * coeff[j*np+k];
gto30[j1*ngrids+i+n] += buf[30*SIMDD+n] * coeff[j*np+k];
gto31[j1*ngrids+i+n] += buf[31*SIMDD+n] * coeff[j*np+k];
gto32[j1*ngrids+i+n] += buf[32*SIMDD+n] * coeff[j*np+k];
gto33[j1*ngrids+i+n] += buf[33*SIMDD+n] * coeff[j*np+k];
gto34[j1*ngrids+i+n] += buf[34*SIMDD+n] * coeff[j*np+k];
gto35[j1*ngrids+i+n] += buf[35*SIMDD+n] * coeff[j*np+k];
} } } } } } }

if (i < bgrids) {
        for (k = 0; k < np; k++) {
                if (_nonzero_in(exps+k*BLKSIZE+i, bgrids-i)) {
for (n = 0; n < SIMDD; n++) {
        fx0[n] = 1;
        fy0[n] = 1;
        fz0[n] = 1;
}
for (lx = 1; lx <= l+3; lx++) {
for (n = 0; n < SIMDD; n++) {
        fx0[lx*SIMDD+n] = fx0[(lx-1)*SIMDD+n] * gridx[i+n];
        fy0[lx*SIMDD+n] = fy0[(lx-1)*SIMDD+n] * gridy[i+n];
        fz0[lx*SIMDD+n] = fz0[(lx-1)*SIMDD+n] * gridz[i+n];
} }
GTO_D_I(1, 0, l+0);
GTO_D_I(2, 0, l+1);
GTO_D_I(3, 2, l+0);
GTO_D_I(4, 0, l+2);
GTO_D_I(5, 4, l+0);
GTO_D_I(6, 4, l+1);
GTO_D_I(7, 6, l+0);
for (lx = l, l1 = 0; lx >= 0; lx--) {
        for (ly = l - lx; ly >= 0; ly--, l1++) {
                lz = l - lx - ly;
                for (n = 0; n < SIMDD; n++) {
                       e = exps[k*BLKSIZE+i+n];
s[0*SIMDD+n] = e * fx7[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[1*SIMDD+n] = e * fx6[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[2*SIMDD+n] = e * fx6[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz1[lz*SIMDD+n];
s[3*SIMDD+n] = e * fx5[lx*SIMDD+n] * fy2[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[4*SIMDD+n] = e * fx4[lx*SIMDD+n] * fy3[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[5*SIMDD+n] = e * fx4[lx*SIMDD+n] * fy2[ly*SIMDD+n] * fz1[lz*SIMDD+n];
s[6*SIMDD+n] = e * fx5[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz2[lz*SIMDD+n];
s[7*SIMDD+n] = e * fx4[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz2[lz*SIMDD+n];
s[8*SIMDD+n] = e * fx4[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz3[lz*SIMDD+n];
s[9*SIMDD+n] = e * fx3[lx*SIMDD+n] * fy4[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[10*SIMDD+n] = e * fx2[lx*SIMDD+n] * fy5[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[11*SIMDD+n] = e * fx2[lx*SIMDD+n] * fy4[ly*SIMDD+n] * fz1[lz*SIMDD+n];
s[12*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy6[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[13*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy7[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[14*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy6[ly*SIMDD+n] * fz1[lz*SIMDD+n];
s[15*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy4[ly*SIMDD+n] * fz2[lz*SIMDD+n];
s[16*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy5[ly*SIMDD+n] * fz2[lz*SIMDD+n];
s[17*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy4[ly*SIMDD+n] * fz3[lz*SIMDD+n];
s[18*SIMDD+n] = e * fx3[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz4[lz*SIMDD+n];
s[19*SIMDD+n] = e * fx2[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz4[lz*SIMDD+n];
s[20*SIMDD+n] = e * fx2[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz5[lz*SIMDD+n];
s[21*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy2[ly*SIMDD+n] * fz4[lz*SIMDD+n];
s[22*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy3[ly*SIMDD+n] * fz4[lz*SIMDD+n];
s[23*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy2[ly*SIMDD+n] * fz5[lz*SIMDD+n];
s[24*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz6[lz*SIMDD+n];
s[25*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz6[lz*SIMDD+n];
s[26*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz7[lz*SIMDD+n];
                }
                for (n = 0; n < SIMDD; n++) {
buf[0*SIMDD+n] = + (-1*s[0*SIMDD+n]);
buf[1*SIMDD+n] = + (-1*s[1*SIMDD+n]);
buf[2*SIMDD+n] = + (-1*s[2*SIMDD+n]);
buf[3*SIMDD+n] = 0;
buf[4*SIMDD+n] = + (-1*s[3*SIMDD+n]);
buf[5*SIMDD+n] = + (-1*s[4*SIMDD+n]);
buf[6*SIMDD+n] = + (-1*s[5*SIMDD+n]);
buf[7*SIMDD+n] = 0;
buf[8*SIMDD+n] = + (-1*s[6*SIMDD+n]);
buf[9*SIMDD+n] = + (-1*s[7*SIMDD+n]);
buf[10*SIMDD+n] = + (-1*s[8*SIMDD+n]);
buf[11*SIMDD+n] = 0;
buf[12*SIMDD+n] = + (-1*s[9*SIMDD+n]);
buf[13*SIMDD+n] = + (-1*s[10*SIMDD+n]);
buf[14*SIMDD+n] = + (-1*s[11*SIMDD+n]);
buf[15*SIMDD+n] = 0;
buf[16*SIMDD+n] = + (-1*s[12*SIMDD+n]);
buf[17*SIMDD+n] = + (-1*s[13*SIMDD+n]);
buf[18*SIMDD+n] = + (-1*s[14*SIMDD+n]);
buf[19*SIMDD+n] = 0;
buf[20*SIMDD+n] = + (-1*s[15*SIMDD+n]);
buf[21*SIMDD+n] = + (-1*s[16*SIMDD+n]);
buf[22*SIMDD+n] = + (-1*s[17*SIMDD+n]);
buf[23*SIMDD+n] = 0;
buf[24*SIMDD+n] = + (-1*s[18*SIMDD+n]);
buf[25*SIMDD+n] = + (-1*s[19*SIMDD+n]);
buf[26*SIMDD+n] = + (-1*s[20*SIMDD+n]);
buf[27*SIMDD+n] = 0;
buf[28*SIMDD+n] = + (-1*s[21*SIMDD+n]);
buf[29*SIMDD+n] = + (-1*s[22*SIMDD+n]);
buf[30*SIMDD+n] = + (-1*s[23*SIMDD+n]);
buf[31*SIMDD+n] = 0;
buf[32*SIMDD+n] = + (-1*s[24*SIMDD+n]);
buf[33*SIMDD+n] = + (-1*s[25*SIMDD+n]);
buf[34*SIMDD+n] = + (-1*s[26*SIMDD+n]);
buf[35*SIMDD+n] = 0;
                }
                for (j = 0, j1 = l1; j < nc; j++, j1+=degen) {
                for (n = 0; n < bgrids-i; n++) {
gto0[j1*ngrids+i+n] += buf[0*SIMDD+n] * coeff[j*np+k];
gto1[j1*ngrids+i+n] += buf[1*SIMDD+n] * coeff[j*np+k];
gto2[j1*ngrids+i+n] += buf[2*SIMDD+n] * coeff[j*np+k];
gto3[j1*ngrids+i+n] += buf[3*SIMDD+n] * coeff[j*np+k];
gto4[j1*ngrids+i+n] += buf[4*SIMDD+n] * coeff[j*np+k];
gto5[j1*ngrids+i+n] += buf[5*SIMDD+n] * coeff[j*np+k];
gto6[j1*ngrids+i+n] += buf[6*SIMDD+n] * coeff[j*np+k];
gto7[j1*ngrids+i+n] += buf[7*SIMDD+n] * coeff[j*np+k];
gto8[j1*ngrids+i+n] += buf[8*SIMDD+n] * coeff[j*np+k];
gto9[j1*ngrids+i+n] += buf[9*SIMDD+n] * coeff[j*np+k];
gto10[j1*ngrids+i+n] += buf[10*SIMDD+n] * coeff[j*np+k];
gto11[j1*ngrids+i+n] += buf[11*SIMDD+n] * coeff[j*np+k];
gto12[j1*ngrids+i+n] += buf[12*SIMDD+n] * coeff[j*np+k];
gto13[j1*ngrids+i+n] += buf[13*SIMDD+n] * coeff[j*np+k];
gto14[j1*ngrids+i+n] += buf[14*SIMDD+n] * coeff[j*np+k];
gto15[j1*ngrids+i+n] += buf[15*SIMDD+n] * coeff[j*np+k];
gto16[j1*ngrids+i+n] += buf[16*SIMDD+n] * coeff[j*np+k];
gto17[j1*ngrids+i+n] += buf[17*SIMDD+n] * coeff[j*np+k];
gto18[j1*ngrids+i+n] += buf[18*SIMDD+n] * coeff[j*np+k];
gto19[j1*ngrids+i+n] += buf[19*SIMDD+n] * coeff[j*np+k];
gto20[j1*ngrids+i+n] += buf[20*SIMDD+n] * coeff[j*np+k];
gto21[j1*ngrids+i+n] += buf[21*SIMDD+n] * coeff[j*np+k];
gto22[j1*ngrids+i+n] += buf[22*SIMDD+n] * coeff[j*np+k];
gto23[j1*ngrids+i+n] += buf[23*SIMDD+n] * coeff[j*np+k];
gto24[j1*ngrids+i+n] += buf[24*SIMDD+n] * coeff[j*np+k];
gto25[j1*ngrids+i+n] += buf[25*SIMDD+n] * coeff[j*np+k];
gto26[j1*ngrids+i+n] += buf[26*SIMDD+n] * coeff[j*np+k];
gto27[j1*ngrids+i+n] += buf[27*SIMDD+n] * coeff[j*np+k];
gto28[j1*ngrids+i+n] += buf[28*SIMDD+n] * coeff[j*np+k];
gto29[j1*ngrids+i+n] += buf[29*SIMDD+n] * coeff[j*np+k];
gto30[j1*ngrids+i+n] += buf[30*SIMDD+n] * coeff[j*np+k];
gto31[j1*ngrids+i+n] += buf[31*SIMDD+n] * coeff[j*np+k];
gto32[j1*ngrids+i+n] += buf[32*SIMDD+n] * coeff[j*np+k];
gto33[j1*ngrids+i+n] += buf[33*SIMDD+n] * coeff[j*np+k];
gto34[j1*ngrids+i+n] += buf[34*SIMDD+n] * coeff[j*np+k];
gto35[j1*ngrids+i+n] += buf[35*SIMDD+n] * coeff[j*np+k];
} } } } } } }
}
void GTOval_ipipsp_cart(int ngrids, int *shls_slice, int *ao_loc,
double *ao, double *coord, uint8_t *non0table,
int *atm, int natm, int *bas, int nbas, double *env)
{
int param[] = {4, 9};
GTOeval_cart_drv(shell_eval_GTOval_ipipsp, GTOprim_exp, 1,
ngrids, param, shls_slice, ao_loc, ao, coord, non0table,
atm, natm, bas, nbas, env);
}
void GTOval_ipipsp_sph(int ngrids, int *shls_slice, int *ao_loc,
double *ao, double *coord, uint8_t *non0table,
int *atm, int natm, int *bas, int nbas, double *env)
{
int param[] = {4, 9};
GTOeval_sph_drv(shell_eval_GTOval_ipipsp, GTOprim_exp, 1,
ngrids, param, shls_slice, ao_loc, ao, coord, non0table,
atm, natm, bas, nbas, env);
}
void GTOval_ipipsp_spinor(int ngrids, int *shls_slice, int *ao_loc,
double complex *ao, double *coord, uint8_t *non0table,
int *atm, int natm, int *bas, int nbas, double *env)
{
int param[] = {4, 9};
GTOeval_spinor_drv(shell_eval_GTOval_ipipsp, GTOprim_exp, CINTc2s_ket_spinor_si1, 1,
ngrids, param, shls_slice, ao_loc, ao, coord, non0table, atm, natm, bas, nbas, env);
}
/*  NABLA RC |GTO> */
static void shell_eval_GTOval_iprc(double *cgto, double *ri, double *exps,
double *coord, double *alpha, double *coeff, double *env,
int l, int np, int nc, size_t nao, size_t ngrids, size_t bgrids)
{
const size_t degen = (l+1)*(l+2)/2;
const size_t bgrids0 = (bgrids >= SIMDD) ? (bgrids+1-SIMDD) : 0;
int lx, ly, lz;
size_t i, j, j1, k, l1, n;
double e;
double *pgto;
double *gridx = coord;
double *gridy = coord+BLKSIZE;
double *gridz = coord+BLKSIZE*2;
double fx0[SIMDD*(ANG_MAX+3)*4];
double fy0[SIMDD*(ANG_MAX+3)*4];
double fz0[SIMDD*(ANG_MAX+3)*4];
double *fx1 = fx0 + SIMDD*(ANG_MAX+3);
double *fy1 = fy0 + SIMDD*(ANG_MAX+3);
double *fz1 = fz0 + SIMDD*(ANG_MAX+3);
double *fx2 = fx1 + SIMDD*(ANG_MAX+3);
double *fy2 = fy1 + SIMDD*(ANG_MAX+3);
double *fz2 = fz1 + SIMDD*(ANG_MAX+3);
double *fx3 = fx2 + SIMDD*(ANG_MAX+3);
double *fy3 = fy2 + SIMDD*(ANG_MAX+3);
double *fz3 = fz2 + SIMDD*(ANG_MAX+3);
double buf[SIMDD*nc*9];
double s[SIMDD*9];
double *gto0 = cgto;
double *gto1 = cgto + nao*ngrids*1;
double *gto2 = cgto + nao*ngrids*2;
double *gto3 = cgto + nao*ngrids*3;
double *gto4 = cgto + nao*ngrids*4;
double *gto5 = cgto + nao*ngrids*5;
double *gto6 = cgto + nao*ngrids*6;
double *gto7 = cgto + nao*ngrids*7;
double *gto8 = cgto + nao*ngrids*8;
double dri[3];
dri[0] = ri[0] - env[PTR_COMMON_ORIG+0];
dri[1] = ri[1] - env[PTR_COMMON_ORIG+1];
dri[2] = ri[2] - env[PTR_COMMON_ORIG+2];

for (j = 0; j < 9; j++) {
        pgto = cgto + j*nao*ngrids;
        for (n = 0; n < degen*nc; n++) {
        for (i = 0; i < bgrids; i++) {
                pgto[n*ngrids+i] = 0;
        } }
}
for (i = 0; i < bgrids0; i+=SIMDD) {
        for (k = 0; k < np; k++) {
                if (_nonzero_in(exps+k*BLKSIZE+i, SIMDD)) {
for (n = 0; n < SIMDD; n++) {
        fx0[n] = 1;
        fy0[n] = 1;
        fz0[n] = 1;
}
for (lx = 1; lx <= l+2; lx++) {
for (n = 0; n < SIMDD; n++) {
        fx0[lx*SIMDD+n] = fx0[(lx-1)*SIMDD+n] * gridx[i+n];
        fy0[lx*SIMDD+n] = fy0[(lx-1)*SIMDD+n] * gridy[i+n];
        fz0[lx*SIMDD+n] = fz0[(lx-1)*SIMDD+n] * gridz[i+n];
} }
GTO_RCI(1, 0, l+0);
GTO_D_I(2, 0, l+1);
GTO_RCI(3, 2, l+0);
for (lx = l, l1 = 0; lx >= 0; lx--) {
        for (ly = l - lx; ly >= 0; ly--, l1++) {
                lz = l - lx - ly;
                for (n = 0; n < SIMDD; n++) {
                       e = exps[k*BLKSIZE+i+n];
s[0*SIMDD+n] = e * fx3[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[1*SIMDD+n] = e * fx2[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[2*SIMDD+n] = e * fx2[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz1[lz*SIMDD+n];
s[3*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy2[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[4*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy3[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[5*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy2[ly*SIMDD+n] * fz1[lz*SIMDD+n];
s[6*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz2[lz*SIMDD+n];
s[7*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz2[lz*SIMDD+n];
s[8*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz3[lz*SIMDD+n];
                }
                for (n = 0; n < SIMDD; n++) {
buf[0*SIMDD+n] = + s[0*SIMDD+n];
buf[1*SIMDD+n] = + s[1*SIMDD+n];
buf[2*SIMDD+n] = + s[2*SIMDD+n];
buf[3*SIMDD+n] = + s[3*SIMDD+n];
buf[4*SIMDD+n] = + s[4*SIMDD+n];
buf[5*SIMDD+n] = + s[5*SIMDD+n];
buf[6*SIMDD+n] = + s[6*SIMDD+n];
buf[7*SIMDD+n] = + s[7*SIMDD+n];
buf[8*SIMDD+n] = + s[8*SIMDD+n];
                }
                for (j = 0, j1 = l1; j < nc; j++, j1+=degen) {
#pragma GCC ivdep
                for (n = 0; n < SIMDD; n++) {
gto0[j1*ngrids+i+n] += buf[0*SIMDD+n] * coeff[j*np+k];
gto1[j1*ngrids+i+n] += buf[1*SIMDD+n] * coeff[j*np+k];
gto2[j1*ngrids+i+n] += buf[2*SIMDD+n] * coeff[j*np+k];
gto3[j1*ngrids+i+n] += buf[3*SIMDD+n] * coeff[j*np+k];
gto4[j1*ngrids+i+n] += buf[4*SIMDD+n] * coeff[j*np+k];
gto5[j1*ngrids+i+n] += buf[5*SIMDD+n] * coeff[j*np+k];
gto6[j1*ngrids+i+n] += buf[6*SIMDD+n] * coeff[j*np+k];
gto7[j1*ngrids+i+n] += buf[7*SIMDD+n] * coeff[j*np+k];
gto8[j1*ngrids+i+n] += buf[8*SIMDD+n] * coeff[j*np+k];
} } } } } } }

if (i < bgrids) {
        for (k = 0; k < np; k++) {
                if (_nonzero_in(exps+k*BLKSIZE+i, bgrids-i)) {
for (n = 0; n < SIMDD; n++) {
        fx0[n] = 1;
        fy0[n] = 1;
        fz0[n] = 1;
}
for (lx = 1; lx <= l+2; lx++) {
for (n = 0; n < SIMDD; n++) {
        fx0[lx*SIMDD+n] = fx0[(lx-1)*SIMDD+n] * gridx[i+n];
        fy0[lx*SIMDD+n] = fy0[(lx-1)*SIMDD+n] * gridy[i+n];
        fz0[lx*SIMDD+n] = fz0[(lx-1)*SIMDD+n] * gridz[i+n];
} }
GTO_RCI(1, 0, l+0);
GTO_D_I(2, 0, l+1);
GTO_RCI(3, 2, l+0);
for (lx = l, l1 = 0; lx >= 0; lx--) {
        for (ly = l - lx; ly >= 0; ly--, l1++) {
                lz = l - lx - ly;
                for (n = 0; n < SIMDD; n++) {
                       e = exps[k*BLKSIZE+i+n];
s[0*SIMDD+n] = e * fx3[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[1*SIMDD+n] = e * fx2[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[2*SIMDD+n] = e * fx2[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz1[lz*SIMDD+n];
s[3*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy2[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[4*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy3[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[5*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy2[ly*SIMDD+n] * fz1[lz*SIMDD+n];
s[6*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz2[lz*SIMDD+n];
s[7*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz2[lz*SIMDD+n];
s[8*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz3[lz*SIMDD+n];
                }
                for (n = 0; n < SIMDD; n++) {
buf[0*SIMDD+n] = + s[0*SIMDD+n];
buf[1*SIMDD+n] = + s[1*SIMDD+n];
buf[2*SIMDD+n] = + s[2*SIMDD+n];
buf[3*SIMDD+n] = + s[3*SIMDD+n];
buf[4*SIMDD+n] = + s[4*SIMDD+n];
buf[5*SIMDD+n] = + s[5*SIMDD+n];
buf[6*SIMDD+n] = + s[6*SIMDD+n];
buf[7*SIMDD+n] = + s[7*SIMDD+n];
buf[8*SIMDD+n] = + s[8*SIMDD+n];
                }
                for (j = 0, j1 = l1; j < nc; j++, j1+=degen) {
                for (n = 0; n < bgrids-i; n++) {
gto0[j1*ngrids+i+n] += buf[0*SIMDD+n] * coeff[j*np+k];
gto1[j1*ngrids+i+n] += buf[1*SIMDD+n] * coeff[j*np+k];
gto2[j1*ngrids+i+n] += buf[2*SIMDD+n] * coeff[j*np+k];
gto3[j1*ngrids+i+n] += buf[3*SIMDD+n] * coeff[j*np+k];
gto4[j1*ngrids+i+n] += buf[4*SIMDD+n] * coeff[j*np+k];
gto5[j1*ngrids+i+n] += buf[5*SIMDD+n] * coeff[j*np+k];
gto6[j1*ngrids+i+n] += buf[6*SIMDD+n] * coeff[j*np+k];
gto7[j1*ngrids+i+n] += buf[7*SIMDD+n] * coeff[j*np+k];
gto8[j1*ngrids+i+n] += buf[8*SIMDD+n] * coeff[j*np+k];
} } } } } } }
}
void GTOval_iprc_cart(int ngrids, int *shls_slice, int *ao_loc,
double *ao, double *coord, uint8_t *non0table,
int *atm, int natm, int *bas, int nbas, double *env)
{
int param[] = {1, 9};
GTOeval_cart_drv(shell_eval_GTOval_iprc, GTOprim_exp, 1,
ngrids, param, shls_slice, ao_loc, ao, coord, non0table,
atm, natm, bas, nbas, env);
}
void GTOval_iprc_sph(int ngrids, int *shls_slice, int *ao_loc,
double *ao, double *coord, uint8_t *non0table,
int *atm, int natm, int *bas, int nbas, double *env)
{
int param[] = {1, 9};
GTOeval_sph_drv(shell_eval_GTOval_iprc, GTOprim_exp, 1,
ngrids, param, shls_slice, ao_loc, ao, coord, non0table,
atm, natm, bas, nbas, env);
}
void GTOval_iprc_spinor(int ngrids, int *shls_slice, int *ao_loc,
double complex *ao, double *coord, uint8_t *non0table,
int *atm, int natm, int *bas, int nbas, double *env)
{
int param[] = {1, 9};
GTOeval_spinor_drv(shell_eval_GTOval_iprc, GTOprim_exp, CINTc2s_ket_spinor_sf1, 1,
ngrids, param, shls_slice, ao_loc, ao, coord, non0table, atm, natm, bas, nbas, env);
}
/*  NABLA R |GTO> */
static void shell_eval_GTOval_ipr(double *cgto, double *ri, double *exps,
double *coord, double *alpha, double *coeff, double *env,
int l, int np, int nc, size_t nao, size_t ngrids, size_t bgrids)
{
const size_t degen = (l+1)*(l+2)/2;
const size_t bgrids0 = (bgrids >= SIMDD) ? (bgrids+1-SIMDD) : 0;
int lx, ly, lz;
size_t i, j, j1, k, l1, n;
double e;
double *pgto;
double *gridx = coord;
double *gridy = coord+BLKSIZE;
double *gridz = coord+BLKSIZE*2;
double fx0[SIMDD*(ANG_MAX+3)*4];
double fy0[SIMDD*(ANG_MAX+3)*4];
double fz0[SIMDD*(ANG_MAX+3)*4];
double *fx1 = fx0 + SIMDD*(ANG_MAX+3);
double *fy1 = fy0 + SIMDD*(ANG_MAX+3);
double *fz1 = fz0 + SIMDD*(ANG_MAX+3);
double *fx2 = fx1 + SIMDD*(ANG_MAX+3);
double *fy2 = fy1 + SIMDD*(ANG_MAX+3);
double *fz2 = fz1 + SIMDD*(ANG_MAX+3);
double *fx3 = fx2 + SIMDD*(ANG_MAX+3);
double *fy3 = fy2 + SIMDD*(ANG_MAX+3);
double *fz3 = fz2 + SIMDD*(ANG_MAX+3);
double buf[SIMDD*nc*9];
double s[SIMDD*9];
double *gto0 = cgto;
double *gto1 = cgto + nao*ngrids*1;
double *gto2 = cgto + nao*ngrids*2;
double *gto3 = cgto + nao*ngrids*3;
double *gto4 = cgto + nao*ngrids*4;
double *gto5 = cgto + nao*ngrids*5;
double *gto6 = cgto + nao*ngrids*6;
double *gto7 = cgto + nao*ngrids*7;
double *gto8 = cgto + nao*ngrids*8;

for (j = 0; j < 9; j++) {
        pgto = cgto + j*nao*ngrids;
        for (n = 0; n < degen*nc; n++) {
        for (i = 0; i < bgrids; i++) {
                pgto[n*ngrids+i] = 0;
        } }
}
for (i = 0; i < bgrids0; i+=SIMDD) {
        for (k = 0; k < np; k++) {
                if (_nonzero_in(exps+k*BLKSIZE+i, SIMDD)) {
for (n = 0; n < SIMDD; n++) {
        fx0[n] = 1;
        fy0[n] = 1;
        fz0[n] = 1;
}
for (lx = 1; lx <= l+2; lx++) {
for (n = 0; n < SIMDD; n++) {
        fx0[lx*SIMDD+n] = fx0[(lx-1)*SIMDD+n] * gridx[i+n];
        fy0[lx*SIMDD+n] = fy0[(lx-1)*SIMDD+n] * gridy[i+n];
        fz0[lx*SIMDD+n] = fz0[(lx-1)*SIMDD+n] * gridz[i+n];
} }
GTO_R_I(1, 0, l+0);
GTO_D_I(2, 0, l+1);
GTO_R_I(3, 2, l+0);
for (lx = l, l1 = 0; lx >= 0; lx--) {
        for (ly = l - lx; ly >= 0; ly--, l1++) {
                lz = l - lx - ly;
                for (n = 0; n < SIMDD; n++) {
                       e = exps[k*BLKSIZE+i+n];
s[0*SIMDD+n] = e * fx3[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[1*SIMDD+n] = e * fx2[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[2*SIMDD+n] = e * fx2[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz1[lz*SIMDD+n];
s[3*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy2[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[4*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy3[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[5*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy2[ly*SIMDD+n] * fz1[lz*SIMDD+n];
s[6*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz2[lz*SIMDD+n];
s[7*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz2[lz*SIMDD+n];
s[8*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz3[lz*SIMDD+n];
                }
                for (n = 0; n < SIMDD; n++) {
buf[0*SIMDD+n] = + s[0*SIMDD+n];
buf[1*SIMDD+n] = + s[1*SIMDD+n];
buf[2*SIMDD+n] = + s[2*SIMDD+n];
buf[3*SIMDD+n] = + s[3*SIMDD+n];
buf[4*SIMDD+n] = + s[4*SIMDD+n];
buf[5*SIMDD+n] = + s[5*SIMDD+n];
buf[6*SIMDD+n] = + s[6*SIMDD+n];
buf[7*SIMDD+n] = + s[7*SIMDD+n];
buf[8*SIMDD+n] = + s[8*SIMDD+n];
                }
                for (j = 0, j1 = l1; j < nc; j++, j1+=degen) {
#pragma GCC ivdep
                for (n = 0; n < SIMDD; n++) {
gto0[j1*ngrids+i+n] += buf[0*SIMDD+n] * coeff[j*np+k];
gto1[j1*ngrids+i+n] += buf[1*SIMDD+n] * coeff[j*np+k];
gto2[j1*ngrids+i+n] += buf[2*SIMDD+n] * coeff[j*np+k];
gto3[j1*ngrids+i+n] += buf[3*SIMDD+n] * coeff[j*np+k];
gto4[j1*ngrids+i+n] += buf[4*SIMDD+n] * coeff[j*np+k];
gto5[j1*ngrids+i+n] += buf[5*SIMDD+n] * coeff[j*np+k];
gto6[j1*ngrids+i+n] += buf[6*SIMDD+n] * coeff[j*np+k];
gto7[j1*ngrids+i+n] += buf[7*SIMDD+n] * coeff[j*np+k];
gto8[j1*ngrids+i+n] += buf[8*SIMDD+n] * coeff[j*np+k];
} } } } } } }

if (i < bgrids) {
        for (k = 0; k < np; k++) {
                if (_nonzero_in(exps+k*BLKSIZE+i, bgrids-i)) {
for (n = 0; n < SIMDD; n++) {
        fx0[n] = 1;
        fy0[n] = 1;
        fz0[n] = 1;
}
for (lx = 1; lx <= l+2; lx++) {
for (n = 0; n < SIMDD; n++) {
        fx0[lx*SIMDD+n] = fx0[(lx-1)*SIMDD+n] * gridx[i+n];
        fy0[lx*SIMDD+n] = fy0[(lx-1)*SIMDD+n] * gridy[i+n];
        fz0[lx*SIMDD+n] = fz0[(lx-1)*SIMDD+n] * gridz[i+n];
} }
GTO_R_I(1, 0, l+0);
GTO_D_I(2, 0, l+1);
GTO_R_I(3, 2, l+0);
for (lx = l, l1 = 0; lx >= 0; lx--) {
        for (ly = l - lx; ly >= 0; ly--, l1++) {
                lz = l - lx - ly;
                for (n = 0; n < SIMDD; n++) {
                       e = exps[k*BLKSIZE+i+n];
s[0*SIMDD+n] = e * fx3[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[1*SIMDD+n] = e * fx2[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[2*SIMDD+n] = e * fx2[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz1[lz*SIMDD+n];
s[3*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy2[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[4*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy3[ly*SIMDD+n] * fz0[lz*SIMDD+n];
s[5*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy2[ly*SIMDD+n] * fz1[lz*SIMDD+n];
s[6*SIMDD+n] = e * fx1[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz2[lz*SIMDD+n];
s[7*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy1[ly*SIMDD+n] * fz2[lz*SIMDD+n];
s[8*SIMDD+n] = e * fx0[lx*SIMDD+n] * fy0[ly*SIMDD+n] * fz3[lz*SIMDD+n];
                }
                for (n = 0; n < SIMDD; n++) {
buf[0*SIMDD+n] = + s[0*SIMDD+n];
buf[1*SIMDD+n] = + s[1*SIMDD+n];
buf[2*SIMDD+n] = + s[2*SIMDD+n];
buf[3*SIMDD+n] = + s[3*SIMDD+n];
buf[4*SIMDD+n] = + s[4*SIMDD+n];
buf[5*SIMDD+n] = + s[5*SIMDD+n];
buf[6*SIMDD+n] = + s[6*SIMDD+n];
buf[7*SIMDD+n] = + s[7*SIMDD+n];
buf[8*SIMDD+n] = + s[8*SIMDD+n];
                }
                for (j = 0, j1 = l1; j < nc; j++, j1+=degen) {
                for (n = 0; n < bgrids-i; n++) {
gto0[j1*ngrids+i+n] += buf[0*SIMDD+n] * coeff[j*np+k];
gto1[j1*ngrids+i+n] += buf[1*SIMDD+n] * coeff[j*np+k];
gto2[j1*ngrids+i+n] += buf[2*SIMDD+n] * coeff[j*np+k];
gto3[j1*ngrids+i+n] += buf[3*SIMDD+n] * coeff[j*np+k];
gto4[j1*ngrids+i+n] += buf[4*SIMDD+n] * coeff[j*np+k];
gto5[j1*ngrids+i+n] += buf[5*SIMDD+n] * coeff[j*np+k];
gto6[j1*ngrids+i+n] += buf[6*SIMDD+n] * coeff[j*np+k];
gto7[j1*ngrids+i+n] += buf[7*SIMDD+n] * coeff[j*np+k];
gto8[j1*ngrids+i+n] += buf[8*SIMDD+n] * coeff[j*np+k];
} } } } } } }
}
void GTOval_ipr_cart(int ngrids, int *shls_slice, int *ao_loc,
double *ao, double *coord, uint8_t *non0table,
int *atm, int natm, int *bas, int nbas, double *env)
{
int param[] = {1, 9};
GTOeval_cart_drv(shell_eval_GTOval_ipr, GTOprim_exp, 1,
ngrids, param, shls_slice, ao_loc, ao, coord, non0table,
atm, natm, bas, nbas, env);
}
void GTOval_ipr_sph(int ngrids, int *shls_slice, int *ao_loc,
double *ao, double *coord, uint8_t *non0table,
int *atm, int natm, int *bas, int nbas, double *env)
{
int param[] = {1, 9};
GTOeval_sph_drv(shell_eval_GTOval_ipr, GTOprim_exp, 1,
ngrids, param, shls_slice, ao_loc, ao, coord, non0table,
atm, natm, bas, nbas, env);
}
void GTOval_ipr_spinor(int ngrids, int *shls_slice, int *ao_loc,
double complex *ao, double *coord, uint8_t *non0table,
int *atm, int natm, int *bas, int nbas, double *env)
{
int param[] = {1, 9};
GTOeval_spinor_drv(shell_eval_GTOval_ipr, GTOprim_exp, CINTc2s_ket_spinor_sf1, 1,
ngrids, param, shls_slice, ao_loc, ao, coord, non0table, atm, natm, bas, nbas, env);
}
